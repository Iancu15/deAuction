{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/AutomationBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract AutomationBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution() internal view {\n    if (tx.origin != address(0)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    preventExecution();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/AutomationCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AutomationBase.sol\";\nimport \"./interfaces/AutomationCompatibleInterface.sol\";\n\nabstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "contracts/Auction.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/AutomationCompatible.sol\";\n\nerror Auction__BidBelowMinimumBid(uint256 amountSent, uint256 minimumBid, uint256 collateralAmount);\nerror Auction__ZeroStartingBid(uint256 amountSent, uint256 collateralAmount);\nerror Auction__RedundantZeroBidIncrease();\nerror Auction__DidntCoverCollateral(uint256 amountSent, uint256 collateralAmount);\nerror Auction__HighestBidderCantWithdraw();\nerror Auction__TransactionFailed();\nerror Auction__MaximumNumbersOfBiddersReached(uint256 maximumNumberOfBidders);\nerror Auction__SellerCantCallFunction();\nerror Auction__DidntEnterAuction();\nerror Auction__AuctionIsStillOpen();\nerror Auction__RoutingReservedForHighestBidder();\nerror Auction__OnlySellerCanCallFunction();\nerror Auction__IntervalBelowThreshold(uint256 interval, uint256 threshold);\nerror Auction__AuctionIsClosed();\nerror Auction__ThresholdNotReached(uint256 timeUntilThreshold);\nerror Auction__UpkeepNotNeeded();\nerror Auction__IntervalAboveMaximum(uint256 interval, uint256 maxInterval);\nerror Auction__AlreadyEnteredAuction();\n\ncontract Auction is AutomationCompatibleInterface {\n    mapping(address => uint256) private s_auctioneerToCurrentBid;\n    address[] private s_auctioneers;\n    address private s_currentHighestBidder;\n    uint256 private s_currentHighestBid;\n    uint256 private s_currentNumberOfBidders;\n    uint256 private  s_closeTimestamp;\n    bool public s_isOpen;\n    address private immutable i_seller;\n    uint256 private immutable i_minimumBid;\n    uint256 private immutable i_maximumNumberOfBidders;\n    uint256 private immutable i_auctioneerCollateralAmount;\n    uint256 private immutable i_sellerCollateralAmount;\n    uint256 private immutable i_interval;\n    uint256 private immutable i_startTimestamp;\n    //uint256 private constant OPEN_INTERVAL_THRESHOLD = 24 * 3600;\n    uint256 private constant OPEN_INTERVAL_THRESHOLD = 0;\n    uint256 private constant CLOSED_INTERVAL = 7 * 24 * 3600;\n    uint256 private constant MAXIMUM_INTERVAL = 7 * 24 * 3600;\n\n    constructor(\n        uint256 minimumBid,\n        uint256 maximumNumberOfBidders,\n        uint256 auctioneerCollateralAmount,\n        uint256 interval\n    ) payable {\n        if (interval < OPEN_INTERVAL_THRESHOLD) {\n            revert Auction__IntervalBelowThreshold(interval, OPEN_INTERVAL_THRESHOLD);\n        }\n\n        if (interval > MAXIMUM_INTERVAL) {\n            revert Auction__IntervalAboveMaximum(interval, MAXIMUM_INTERVAL);\n        }\n\n        i_minimumBid = minimumBid;\n        i_seller = msg.sender;\n        i_maximumNumberOfBidders = maximumNumberOfBidders;\n        i_auctioneerCollateralAmount = auctioneerCollateralAmount;\n        i_sellerCollateralAmount = msg.value;\n        i_interval = interval;\n        i_startTimestamp = block.timestamp;\n        s_isOpen = true;\n        s_currentNumberOfBidders = 0;\n    }\n\n    modifier auctionClosed() {\n        if (s_isOpen) {\n            revert Auction__AuctionIsStillOpen();\n        }\n        _;\n    }\n\n    modifier auctionOpen() {\n        if (!s_isOpen) {\n            revert Auction__AuctionIsClosed();\n        }\n        _;\n    }\n\n    modifier onlySeller() {\n        if (msg.sender != i_seller) {\n            revert Auction__OnlySellerCanCallFunction();\n        }\n        _;\n    }\n\n    modifier notSeller() {\n        if (msg.sender == i_seller) {\n            revert Auction__SellerCantCallFunction();\n        }\n        _;\n    }\n\n    function enterAuction() public payable notSeller auctionOpen {\n        if (s_auctioneerToCurrentBid[msg.sender] > 0) {\n            revert Auction__AlreadyEnteredAuction();\n        }\n\n        if (s_currentNumberOfBidders == i_maximumNumberOfBidders) {\n            revert Auction__MaximumNumbersOfBiddersReached(\n                i_maximumNumberOfBidders\n            );\n        }\n\n        if (msg.value < i_auctioneerCollateralAmount) {\n            revert Auction__DidntCoverCollateral({\n                amountSent: msg.value,\n                collateralAmount: i_auctioneerCollateralAmount\n            });\n        }\n\n        uint256 startingBid = msg.value - i_auctioneerCollateralAmount;\n        if (startingBid == 0) {\n            revert Auction__ZeroStartingBid({\n                amountSent: msg.value,\n                collateralAmount: i_auctioneerCollateralAmount\n            });\n        }\n\n        if (startingBid < i_minimumBid) {\n            revert Auction__BidBelowMinimumBid({\n                amountSent: msg.value,\n                minimumBid: i_minimumBid,\n                collateralAmount: i_auctioneerCollateralAmount\n            });\n        }\n\n        s_auctioneerToCurrentBid[msg.sender] = startingBid;\n        if (startingBid > s_currentHighestBid) {\n            s_currentHighestBid = startingBid;\n            s_currentHighestBidder = msg.sender;\n        }\n\n        s_currentNumberOfBidders++;\n        s_auctioneers.push(msg.sender);\n    }\n\n    function increaseBid() public payable auctionOpen {\n        uint256 currentBid = s_auctioneerToCurrentBid[msg.sender];\n        if (currentBid == 0) {\n            revert Auction__DidntEnterAuction();\n        }\n\n        if (msg.value == 0) {\n            revert Auction__RedundantZeroBidIncrease();\n        }\n\n        currentBid += msg.value;\n        s_auctioneerToCurrentBid[msg.sender] = currentBid;\n        if (currentBid > s_currentHighestBid) {\n            s_currentHighestBid = currentBid;\n            s_currentHighestBidder = msg.sender;\n        }\n    }\n\n    function leaveAuction() public auctionOpen {\n        if (msg.sender == s_currentHighestBidder) {\n            revert Auction__HighestBidderCantWithdraw();\n        }\n\n        uint256 currentBid = s_auctioneerToCurrentBid[msg.sender];\n        if (currentBid == 0) {\n            revert Auction__DidntEnterAuction();\n        }\n\n        s_auctioneerToCurrentBid[msg.sender] = 0;\n        s_currentNumberOfBidders -= 1;\n        (bool success, ) = payable(msg.sender).call{\n            value: currentBid + i_auctioneerCollateralAmount\n        }(\"\");\n\n        if (!success) {\n            revert Auction__TransactionFailed();\n        }\n    }\n\n    function closeAuction() public onlySeller auctionOpen {\n        if (!canICloseAuction()) {\n            revert Auction__ThresholdNotReached(getTimeUntilThreshold());\n        }\n\n        if (s_currentHighestBid == 0) {\n            (bool success, ) = payable(i_seller).call{\n                value: i_sellerCollateralAmount\n            }(\"\");\n\n            if (!success) {\n                revert Auction__TransactionFailed();\n            }\n\n            destroyContract();\n        }\n\n        s_isOpen = false;\n        s_closeTimestamp = block.timestamp;\n        address[] memory auctioneers = s_auctioneers;\n        for (uint256 index = 0; index < auctioneers.length; index++) {\n            address auctioneer = auctioneers[index];\n            uint256 bid = s_auctioneerToCurrentBid[auctioneer];\n            if (bid == 0 || auctioneer == s_currentHighestBidder) {\n                continue;\n            }\n\n            s_auctioneerToCurrentBid[auctioneer] = 0;\n            (bool success, ) = payable(auctioneer).call{\n                value: bid + i_auctioneerCollateralAmount\n            }(\"\");\n\n            if (!success) {\n                revert Auction__TransactionFailed();\n            }\n        }\n    }\n\n    function routeHighestBid() public auctionClosed {\n        if (msg.sender != s_currentHighestBidder) {\n            revert Auction__RoutingReservedForHighestBidder();\n        }\n\n        (bool success, ) = payable(i_seller).call{\n            value: s_currentHighestBid + i_sellerCollateralAmount\n        }(\"\");\n\n        if (!success) {\n            revert Auction__TransactionFailed();\n        }\n\n        (success, ) = payable(s_currentHighestBidder).call{\n            value: i_auctioneerCollateralAmount\n        }(\"\");\n\n        if (!success) {\n            revert Auction__TransactionFailed();\n        }\n\n        destroyContract();\n    }\n\n    function burnAllStoredValue() public auctionClosed onlySeller {\n        destroyContract();\n    }\n\n    function checkUpkeep(bytes memory)\n        public\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory)\n    {\n        if (s_isOpen) {\n            upkeepNeeded = getTimePassedSinceStart() >= i_interval;\n        } else {\n            upkeepNeeded = getTimePassedSinceAuctionClosed() >= CLOSED_INTERVAL;\n        }\n\n        return (upkeepNeeded, \"0x0\");\n    }\n\n    function performUpkeep(bytes calldata) external override {\n        (bool upkeepNeeded, ) = checkUpkeep(\"\");\n        if (!upkeepNeeded) {\n            revert Auction__UpkeepNotNeeded();\n        }\n\n        if (s_isOpen) {\n            closeAuction();\n        } else {\n            destroyContract();\n        }\n    }\n\n    function destroyContract() internal {\n        selfdestruct(payable(address(this)));\n    }\n\n    function getAuctionWinner()\n        public\n        view\n        auctionClosed\n        onlySeller\n        returns (address)\n    {\n        return s_currentHighestBidder;\n    }\n\n    function getMyCurrentBid() public view notSeller returns (uint256) {\n        return s_auctioneerToCurrentBid[msg.sender];\n    }\n\n    function getContractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function getCurrentHighestBid() public view returns (uint256) {\n        return s_currentHighestBid;\n    }\n\n    function doIHaveTheHighestBid() public view notSeller returns (bool) {\n        return msg.sender == s_currentHighestBidder;\n    }\n\n    function getMinimumBid() public view returns (uint256) {\n        return i_minimumBid;\n    }\n\n    function getSellerAddress() public view returns (address) {\n        return i_seller;\n    }\n\n    function isOpen() public view returns (bool) {\n        return s_isOpen;\n    }\n\n    function getNumberOfBidders() public view returns (uint256) {\n        return s_currentNumberOfBidders;\n    }\n\n    function getMaximumNumberOfBidders() public view returns (uint256) {\n        return i_maximumNumberOfBidders;\n    }\n\n    function getAuctioneerCollateralAmount() public view returns (uint256) {\n        return i_auctioneerCollateralAmount;\n    }\n\n    function getSellerCollateralAmount() public view returns (uint256) {\n        return i_sellerCollateralAmount;\n    }\n\n    function getInterval() public view returns (uint256) {\n        return i_interval;\n    }\n\n    function getStartTimestamp() public view returns (uint256) {\n        return i_startTimestamp;\n    }\n\n    function getOpenThreshold() public pure returns (uint256) {\n        return OPEN_INTERVAL_THRESHOLD;\n    }\n\n    function getTimePassedSinceStart() public view returns (uint256) {\n        return block.timestamp - i_startTimestamp;\n    }\n\n    function getTimeUntilClosing() public view auctionOpen returns (uint256) {\n        return i_interval - getTimePassedSinceStart();\n    }\n\n    function getTimeUntilThreshold() public view returns (uint256) {\n        return (getTimePassedSinceStart() >= OPEN_INTERVAL_THRESHOLD) ? 0 : (OPEN_INTERVAL_THRESHOLD - getTimePassedSinceStart());\n    }\n\n    function getCloseTimestamp() public view auctionClosed returns (uint256) {\n        return s_closeTimestamp;\n    }\n\n    function getTimePassedSinceAuctionClosed() public view auctionClosed returns (uint256) {\n        return block.timestamp - s_closeTimestamp;\n    }\n\n    function getClosedInterval() public pure returns (uint256) {\n        return CLOSED_INTERVAL;\n    }\n\n    function getTimeUntilDestroy() public view auctionClosed returns (uint256) {\n        return CLOSED_INTERVAL - getTimePassedSinceAuctionClosed();\n    }\n\n    function canICloseAuction() public view onlySeller returns (bool) {\n        return getTimeUntilThreshold() == 0;\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}